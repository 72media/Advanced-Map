<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Map with HTML Support in Marker Details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet CSS and Plugins -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <!-- MarkerCluster CSS for grouping markers -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }

    .leaflet-popup-content {
      max-width: 640px !important;
      max-height: 500px;
      overflow-y: auto;
    }

    .leaflet-popup-content iframe {
      width: 100% !important;
      height: auto !important;
      aspect-ratio: 16 / 9;
      border: none;
    }
    
    /* Style for the video player */
    .leaflet-popup-content video {
      width: 100% !important;
      height: auto !important;
      background-color: #000;
    }

    .marker-content {
      margin-top: 10px;
    }

    .controls {
      position: absolute;
      top: 10px;
      left: 10.5%;
      transform: translateX(-50%);
      background: white;
      color: black;
      z-index: 1000;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      max-width: 200px;
      text-align: center;
    }
    
    .controls label, .controls input, .controls button {
      display: block;
      margin-top: 5px;
      width: 100%;
    }

    .toggle-btn {
      position: absolute;
      top: 10px;
      left: 55px;
      z-index: 1100;
      padding: 5px 10px;
      background: white;
      color: black;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: white;
      color: black;
      padding: 20px;
      border-radius: 10px;
      width: 400px;
      max-width: 90%;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .modal-content h2 {
      margin-top: 0;
    }

    .modal-content input,
    .modal-content textarea,
    .modal-content select {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    
    .modal-content .icon-preview {
        display: block;
        margin: 5px auto;
        width: 32px;
        height: 32px;
    }

    .modal-content button {
      padding: 8px 15px;
      margin-right: 10px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 5px; /* Added spacing */
    }

    .modal-content .ai-buttons {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .modal-content .ai-buttons button {
      flex: 1;
      margin: 0 5px;
    }
    
    .html-hint {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 10px;
    }
    .hidden {
      display: none;
    }
    .full-screen-btn {
        display: block;
        margin: 10px auto 0 auto;
        padding: 8px 15px;
        background-color: transparent; /* Remove background */
        color: white; /* White text */
        font-size: 1.2em; /* Larger font size */
        text-decoration: none;
        border-radius: 4px;
        text-align: center;
        font-weight: bold;
    }
    
    /* Toast Notification styles */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3000;
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
    }
    .toast {
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      margin-top: 10px;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    .toast.show {
      opacity: 1;
    }

    /* CSS for the tilt effect */
    #map.tilted {
      transform: perspective(1000px) rotateX(45deg);
      transition: transform 0.5s ease;
    }
  </style>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.5/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <!-- MarkerCluster JS for grouping markers -->
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
</head>
<body>

<button class="toggle-btn" onclick="toggleControls()">‚ò∞</button>
<div class="controls" id="toolbox">
  <h3>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠</h3>
  <label>üìÇ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
    <input type="file" id="file" accept=".geojson,.json,.kml,.gpx" />
  </label>
  <p class="html-hint">‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö .geojson, .kml, .gpx</p>
  <hr>
  <!-- Updated coordinate search section -->
  <h3>‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏û‡∏¥‡∏Å‡∏±‡∏î</h3>
  <input type="text" id="coords-input" placeholder="‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î ‡πÄ‡∏ä‡πà‡∏ô 19.67,98.97" />
  <button id="search-coords-btn">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î</button>
  <hr>
  <label for="opacity-slider">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏∂‡∏ö‡πÅ‡∏™‡∏á‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ã‡πâ‡∏≠‡∏ô</label>
  <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="1" />
  <button id="toggle-tilt-btn">‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÄ‡∏≠‡∏µ‡∏¢‡∏á</button>
  <button id="saveGeoJSON">üíæ Export to GeoJSON</button>
  <button id="clear">üßπ Clear All</button>
  <button id="reset">üîÑ Reset View</button>
</div>

<div id="map"></div>

<!-- Modal to add marker details -->
<div class="modal" id="markerModal">
  <div class="modal-content">
    <h2>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î Marker</h2>
    <label for="icon-select">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô:</label>
    <select id="icon-select">
      <option value="">‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</option>
      <option value="https://i.ibb.co/mf8MtwZ/camera.png">‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ß‡∏á‡∏à‡∏£‡∏õ‡∏¥‡∏î</option>
      <option value="http://maps.google.com/mapfiles/kml/shapes/earthquake.png">‡πÅ‡∏ú‡πà‡∏ô‡∏î‡∏¥‡∏ô‡πÑ‡∏´‡∏ß</option>
      <option value="http://maps.google.com/mapfiles/kml/shapes/volcano.png">‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü</option>
      <option value="http://maps.google.com/mapfiles/kml/shapes/firedept.png">‡∏à‡∏∏‡∏î‡πÑ‡∏ü‡πÑ‡∏´‡∏°‡πâ</option>
    </select>
    <img id="icon-preview" class="icon-preview" src="" alt="Selected Icon" style="display:none;" />
    
    <label for="markerTitle">‡∏ä‡∏∑‡πà‡∏≠:</label>
    <input type="text" id="markerTitle" placeholder="‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠" />
    
    <label for="markerDesc">‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î:</label>
    <textarea id="markerDesc" placeholder='‡πÉ‡∏™‡πà‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (‡πÉ‡∏ä‡πâ HTML ‡πÑ‡∏î‡πâ)' rows="6"></textarea>
    <p class="html-hint">‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏ó‡∏£‡∏Å HTML ‡πÑ‡∏î‡πâ ‡πÄ‡∏ä‡πà‡∏ô iframe ‡∏à‡∏≤‡∏Å Google Drive ‡∏´‡∏£‡∏∑‡∏≠ YouTube</p>
    
    <!-- New AI buttons for generating and summarizing descriptions -->
    <div class="ai-buttons">
      <button id="generate-desc-btn">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î ‚ú®</button>
      <button id="summarize-desc-btn">‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î ‚ú®</button>
    </div>
    
    <!-- New button for TTS -->
    <button id="read-aloud-btn">‡∏≠‡πà‡∏≤‡∏ô‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‚ú®</button>

    <button onclick="saveMarkerDetails()">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
    <button onclick="cancelMarkerDetails()">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
  </div>
</div>

<!-- Modal to confirm clearing all layers -->
<div class="modal" id="clearConfirmModal">
  <div class="modal-content">
    <h2>‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</h2>
    <p>‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏ó‡∏∏‡∏Å‡πÄ‡∏•‡πÄ‡∏¢‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞ Marker ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î?</p>
    <button onclick="confirmClear()">‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</button>
    <button onclick="cancelClear()">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
  </div>
</div>

<!-- Container for toast notifications -->
<div id="toast-container" class="toast-container"></div>
<audio id="audio-player"></audio>

<script>
const defaultView = [13.736717, 100.523186];
const map = L.map('map').setView(defaultView, 6);

// Define different base map layers
const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

const satelliteLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
    maxZoom: 19,
    attribution: 'Imagery &copy; Google Maps'
});

const hybridLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
    maxZoom: 19,
    attribution: 'Imagery &copy; Google Maps'
}).addTo(map); // Set as default layer

const topoMapLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    maxZoom: 17,
    attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
});

// Object to hold base map layers for the control
const baseMaps = {
    "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô": osmLayer,
    "‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏°": satelliteLayer,
    "‡∏•‡∏π‡∏Å‡∏ú‡∏™‡∏°": hybridLayer,
    "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏†‡∏π‡∏°‡∏¥‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®": topoMapLayer
};

// Add the layers control to the map
L.control.layers(baseMaps).addTo(map);

const markers = L.markerClusterGroup();
map.addLayer(markers);

const drawnItems = new L.FeatureGroup().addTo(map);
let imageOverlay = null; // Store the image overlay layer

// Initialize the draw control for creating new shapes and markers
const drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems },
  draw: { marker: true, polyline: true, polygon: true, circle: true, rectangle: true }
});
map.addControl(drawControl);

let currentLayer = null;

// Handle the creation of new layers
map.on(L.Draw.Event.CREATED, function (e) {
  const layer = e.layer;
  if (e.layerType === 'marker') {
    currentLayer = layer;
    showMarkerModal(e.layer.getLatLng()); // Pass the latlng to the modal function
  } else {
    // Add other shapes directly to the drawnItems layer group
    drawnItems.addLayer(layer);
  }
});

// Function to show a toast notification
function showToast(message, duration = 3000) {
  const toastContainer = document.getElementById('toast-container');
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  toastContainer.appendChild(toast);
  
  // Show toast with a slight delay
  setTimeout(() => toast.classList.add('show'), 10);
  
  // Hide toast after a duration
  setTimeout(() => {
    toast.classList.remove('show');
    // Remove toast from DOM after it fades out
    setTimeout(() => toast.remove(), 500); 
  }, duration);
}

let customIconUrl = '';

// Function to show the marker details modal
function showMarkerModal(latlng) {
  currentLayer.latlng = latlng; // Store the latlng on the layer
  document.getElementById('markerModal').style.display = 'flex';
  document.getElementById('markerTitle').value = '';
  document.getElementById('markerDesc').value = '';
  document.getElementById('icon-select').value = '';
  document.getElementById('icon-preview').style.display = 'none';
  customIconUrl = ''; // Reset the icon URL
}

// Function to save marker details and add to map
function saveMarkerDetails() {
  if (!currentLayer || !currentLayer.latlng) {
    console.error("Error: currentLayer or its latlng property is undefined.");
    return;
  }
  const title = document.getElementById('markerTitle').value || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠';
  const desc = document.getElementById('markerDesc').value || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î';
  const selectedIconUrl = document.getElementById('icon-select').value;
  
  // Create a custom icon if one is selected
  let finalMarker;
  if (selectedIconUrl) {
    const customIcon = L.icon({
      iconUrl: selectedIconUrl,
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    finalMarker = L.marker(currentLayer.latlng, { icon: customIcon });
  } else {
    // Use default marker
    finalMarker = L.marker(currentLayer.latlng);
  }

  const cleanDesc = DOMPurify.sanitize(desc, {
    ALLOWED_TAGS: ['a', 'p', 'div', 'br', 'iframe', 'img', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'strong', 'em', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['href', 'src', 'width', 'height', 'frameborder', 'allowfullscreen', 'target', 'style', 'allow']
  });
  
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = cleanDesc;
  const iframe = tempDiv.querySelector('iframe');
  let youtubeUrl = null;
  if (iframe) {
    const src = iframe.getAttribute('src');
    if (src && src.includes('youtube.com/embed')) {
      youtubeUrl = src;
    }
  }

  let fullScreenButton = '';
  if (youtubeUrl) {
    fullScreenButton = `<br><br><a href="${youtubeUrl}" target="_blank" style="display: inline-block; padding: 8px 15px; background-color: transparent; color: white; text-decoration: none; border-radius: 4px;">‡∏î‡∏π‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</a>`;
  }
  
  const popupContent = `
    <div style="max-width:640px;">
      <b>${title}</b><br>
      <div class="marker-content">${cleanDesc}${fullScreenButton}</div>
    </div>
  `;

  finalMarker.bindPopup(popupContent, {
    maxWidth: 660,
    minWidth: 320
  });

  markers.addLayer(finalMarker); // Add marker to the cluster group
  document.getElementById('markerModal').style.display = 'none';
  if (currentLayer) {
    map.removeLayer(currentLayer); // Remove the temporary marker
  }
  currentLayer = null;
}

// Function to cancel marker creation
function cancelMarkerDetails() {
  document.getElementById('markerModal').style.display = 'none';
  if (currentLayer) {
    map.removeLayer(currentLayer);
  }
  currentLayer = null;
}

// Function to toggle the visibility of the control panel
function toggleControls() {
  document.getElementById('toolbox').classList.toggle('hidden');
}

// Show clear confirmation modal instead of using confirm()
document.getElementById('clear').addEventListener('click', () => {
  document.getElementById('clearConfirmModal').style.display = 'flex';
});

// Function to handle the "Clear" button in the confirmation modal
function confirmClear() {
  drawnItems.clearLayers();
  markers.clearLayers();
  if (imageOverlay) {
    map.removeLayer(imageOverlay);
    imageOverlay = null;
  }
  document.getElementById('clearConfirmModal').style.display = 'none';
  showToast('‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß');
}

// Function to handle the "Cancel" button in the confirmation modal
function cancelClear() {
  document.getElementById('clearConfirmModal').style.display = 'none';
}

// Reset map view to the default location and zoom level
document.getElementById('reset').addEventListener('click', () => {
  map.setView(defaultView, 6);
  showToast('‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß');
});

// New code for file upload
document.getElementById('file').addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (!file) {
    return;
  }

  const reader = new FileReader();
  reader.onload = function (event) {
    const content = event.target.result;
    const extension = file.name.split('.').pop().toLowerCase();

    // Check for KML files with a GroundOverlay
    if (extension === 'kml' && content.includes('<GroundOverlay>')) {
      try {
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(content, 'text/xml');
        const groundOverlays = kmlDoc.querySelectorAll('GroundOverlay');

        groundOverlays.forEach(overlay => {
          const latLonBox = overlay.querySelector('LatLonBox');
          const href = overlay.querySelector('Icon href');
          
          if (latLonBox && href) {
            const north = parseFloat(latLonBox.querySelector('north').textContent);
            const south = parseFloat(latLonBox.querySelector('south').textContent);
            const east = parseFloat(latLonBox.querySelector('east').textContent);
            const west = parseFloat(latLonBox.querySelector('west').textContent);
            const imageUrl = href.textContent;
            
            const bounds = [[south, west], [north, east]];
            
            if (imageOverlay) {
              map.removeLayer(imageOverlay);
            }
            
            imageOverlay = L.imageOverlay(imageUrl, bounds, { opacity: parseFloat(document.getElementById('opacity-slider').value) }).addTo(map);
            map.fitBounds(bounds);
            showToast('‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ã‡πâ‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå KML ‡πÅ‡∏•‡πâ‡∏ß');
          }
        });
      } catch (error) {
        showToast(`Error parsing KML GroundOverlay file: ${error.message}`, 5000);
        return;
      }
    }
    
    // Use omnivore for all other KML features, GeoJSON, and GPX
    let layer;
    try {
      if (extension === 'geojson' || extension === 'json') {
        layer = L.geoJSON(JSON.parse(content));
      } else if (extension === 'kml') {
        layer = omnivore.kml.parse(content);
      } else if (extension === 'gpx') {
        layer = omnivore.gpx.parse(content);
      }
    } catch (error) {
      showToast(`Error parsing file: ${error.message}`, 5000);
      return;
    }
    
    if (layer) {
      layer.eachLayer(function(l) {
        if (l instanceof L.Marker) {
          markers.addLayer(l); // Add markers to the cluster group
          setupPopup(l, l.feature.properties);
        } else {
          drawnItems.addLayer(l); // Add other shapes to the drawn items group
          setupPopup(l, l.feature.properties);
        }
      });
      
      const bounds = layer.getBounds();
      if (bounds.isValid()) {
        map.fitBounds(bounds);
      } else {
        showToast('‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏ó‡∏≤‡∏á‡∏†‡∏π‡∏°‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 5000);
      }
      showToast('‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏•‡πâ‡∏ß');
    } else {
      showToast('‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á!', 5000);
    }
  };

  reader.readAsText(file);
});

// Function to set up the popup for a given layer
function setupPopup(layer, properties) {
  if (properties) {
    let popupContent = "";
    const description = properties.description || '';
    const m3u8UrlMatch = description.match(/(https?:\/\/[^\s]+\.m3u8)/);

    if (properties.name) {
      popupContent += `<b>${properties.name}</b><br>`;
    }

    if (m3u8UrlMatch) {
      const m3u8Url = m3u8UrlMatch[0];
      popupContent += `
        <div class="marker-content">
          <video id="hls-video-${L.stamp(layer)}" class="hls-video-player" controls muted></video>
          <a href="${m3u8Url}" target="_blank" class="full-screen-btn">‡∏î‡∏π‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠</a>
        </div>
      `;
      layer.on('popupopen', function() {
        const video = document.getElementById(`hls-video-${L.stamp(layer)}`);
        if (Hls.isSupported() && video) {
          var hls = new Hls();
          hls.loadSource(m3u8Url);
          hls.attachMedia(video);
          hls.on(Hls.Events.MANIFEST_PARSED, function() {
            video.play();
          });
        } else if (video && video.canPlayType('application/vnd.apple.mpegurl')) {
          video.src = m3u8Url;
          video.addEventListener('loadedmetadata', function() {
            video.play();
          });
        }
      });
    } else if (description) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = description;
      const iframe = tempDiv.querySelector('iframe');
      let fullScreenButton = '';
      if (iframe) {
        const src = iframe.getAttribute('src');
        if (src && src.includes('youtube.com/embed')) {
          fullScreenButton = `<br><br><a href="${src}" target="_blank" style="display: inline-block; padding: 8px 15px; background-color: transparent; color: white; text-decoration: none; border-radius: 4px;">‡∏î‡∏π‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</a>`;
        }
      }
      popupContent += `<div class="marker-content">${description}${fullScreenButton}</div>`;
    }
    
    if (popupContent) {
      layer.bindPopup(popupContent, {
        maxWidth: 660,
        minWidth: 320
      });
    }
  }
}

// Event listener for the opacity slider
document.getElementById('opacity-slider').addEventListener('input', (e) => {
  const opacity = e.target.value;
  if (imageOverlay) {
    imageOverlay.setOpacity(opacity);
  }
});

// New event listener for the tilt button
document.getElementById('toggle-tilt-btn').addEventListener('click', () => {
  const mapElement = document.getElementById('map');
  mapElement.classList.toggle('tilted');
});

// Event listener to show a preview of the selected icon
document.getElementById('icon-select').addEventListener('change', (e) => {
    const iconUrl = e.target.value;
    const iconPreview = document.getElementById('icon-preview');
    if (iconUrl) {
        iconPreview.src = iconUrl;
        iconPreview.style.display = 'block';
    } else {
        iconPreview.style.display = 'none';
    }
});

// --- Gemini API Integration ---

// Function to call the Gemini Text Generation API
async function callGeminiTextAPI(prompt) {
  const apiKey = "";
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

  let chatHistory = [];
  chatHistory.push({ role: "user", parts: [{ text: prompt }] });
  const payload = { contents: chatHistory };

  let response;
  const maxRetries = 3;
  let attempt = 0;

  while (attempt < maxRetries) {
    try {
      response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (response.ok) {
        const result = await response.json();
        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          return result.candidates[0].content.parts[0].text;
        } else {
          return "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
        }
      } else {
        const errorData = await response.json();
        console.error(`Gemini Text API Error (Attempt ${attempt + 1}):`, errorData);
        if (response.status === 429 && attempt < maxRetries - 1) {
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          attempt++;
        } else {
          return "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Gemini API";
        }
      }
    } catch (error) {
      console.error(`Fetch Error (Attempt ${attempt + 1}):`, error);
      return "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠";
    }
  }
  return "‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏•‡∏≠‡∏á‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏•‡πâ‡∏ß";
}

// Function to call the Gemini Text-to-Speech API
async function callGeminiTtsAPI(text) {
  const payload = {
    contents: [{
      parts: [{ text: text }]
    }],
    generationConfig: {
      responseModalities: ["AUDIO"],
      speechConfig: {
        voiceConfig: {
          prebuiltVoiceConfig: { voiceName: "Kore" }
        }
      }
    }
  };
  const apiKey = "";
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

  let response;
  const maxRetries = 3;
  let attempt = 0;

  while (attempt < maxRetries) {
    try {
      response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (response.ok) {
        const result = await response.json();
        const part = result?.candidates?.[0]?.content?.parts?.[0];
        const audioData = part?.inlineData?.data;
        const mimeType = part?.inlineData?.mimeType;

        if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
          // Convert base64 to ArrayBuffer
          const pcmData = base64ToArrayBuffer(audioData);
          const pcm16 = new Int16Array(pcmData);

          // Get sample rate from mimeType, e.g., "audio/L16;rate=24000"
          const sampleRateMatch = mimeType.match(/rate=(\d+)/);
          const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;

          // Convert PCM to WAV
          const wavBlob = pcmToWav(pcm16, sampleRate);
          const audioUrl = URL.createObjectURL(wavBlob);
          return audioUrl;
        } else {
          showToast('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö');
          return null;
        }
      } else {
        const errorData = await response.json();
        console.error(`Gemini TTS API Error (Attempt ${attempt + 1}):`, errorData);
        if (response.status === 429 && attempt < maxRetries - 1) {
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          attempt++;
        } else {
          showToast("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Gemini TTS API");
          return null;
        }
      }
    } catch (error) {
      console.error(`Fetch Error (Attempt ${attempt + 1}):`, error);
      showToast("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠");
      return null;
    }
  }
  showToast("‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏•‡∏≠‡∏á‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏•‡πâ‡∏ß");
  return null;
}

// Helper function to convert base64 to ArrayBuffer
function base64ToArrayBuffer(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

// Helper function to convert PCM audio data to a WAV file Blob
function pcmToWav(pcmData, sampleRate) {
  const buffer = new ArrayBuffer(44 + pcmData.length * 2);
  const view = new DataView(buffer);

  // RIFF identifier
  writeString(view, 0, 'RIFF');
  // file length (unknown, so we write it later)
  view.setUint32(4, 36 + pcmData.length * 2, true);
  // RIFF type
  writeString(view, 8, 'WAVE');
  // format chunk identifier
  writeString(view, 12, 'fmt ');
  // format chunk length
  view.setUint32(16, 16, true);
  // sample format (1 = PCM)
  view.setUint16(20, 1, true);
  // channel count
  view.setUint16(22, 1, true);
  // sample rate
  view.setUint32(24, sampleRate, true);
  // byte rate (sample rate * block align)
  view.setUint32(28, sampleRate * 2, true);
  // block align (2 bytes for 16-bit PCM)
  view.setUint16(32, 2, true);
  // bits per sample
  view.setUint16(34, 16, true);
  // data chunk identifier
  writeString(view, 36, 'data');
  // data chunk length
  view.setUint32(40, pcmData.length * 2, true);

  // Write PCM audio data
  let offset = 44;
  for (let i = 0; i < pcmData.length; i++, offset += 2) {
    view.setInt16(offset, pcmData[i], true);
  }

  return new Blob([view], { type: 'audio/wav' });
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

// Event listener for the "Generate Description" button
document.getElementById('generate-desc-btn').addEventListener('click', async () => {
  const title = document.getElementById('markerTitle').value;
  const descTextarea = document.getElementById('markerDesc');
  
  if (!title) {
    showToast('‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠ Marker ‡∏Å‡πà‡∏≠‡∏ô', 3000);
    return;
  }
  
  // Show loading state
  descTextarea.value = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î...';
  descTextarea.disabled = true;

  const prompt = `‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á Marker ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ó‡∏µ‡πà‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢: '${title}'`;
  const generatedText = await callGeminiTextAPI(prompt);
  
  // Update textarea and remove loading state
  descTextarea.value = generatedText;
  descTextarea.disabled = false;
  showToast('‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏î‡πâ‡∏ß‡∏¢ AI ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß');
});

// Event listener for the "Summarize Description" button
document.getElementById('summarize-desc-btn').addEventListener('click', async () => {
  const descTextarea = document.getElementById('markerDesc');
  const originalText = descTextarea.value;
  
  if (!originalText || originalText === '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î...') {
    showToast('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÉ‡∏´‡πâ‡∏™‡∏£‡∏∏‡∏õ', 3000);
    return;
  }
  
  // Show loading state
  descTextarea.value = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î...';
  descTextarea.disabled = true;

  const prompt = `‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πà‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡πÇ‡∏õ‡∏£‡∏î‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏™‡∏±‡πâ‡∏ô‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢: '${originalText}'`;
  const summarizedText = await callGeminiTextAPI(prompt);
  
  // Update textarea and remove loading state
  descTextarea.value = summarizedText;
  descTextarea.disabled = false;
  showToast('‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏î‡πâ‡∏ß‡∏¢ AI ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß');
});

// New event listener for the "Read Aloud" button
document.getElementById('read-aloud-btn').addEventListener('click', async () => {
  const descTextarea = document.getElementById('markerDesc');
  const textToRead = descTextarea.value;
  const audioPlayer = document.getElementById('audio-player');

  if (!textToRead || textToRead.trim() === '') {
    showToast('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô');
    return;
  }
  
  // Disable button and show loading state
  const readAloudButton = document.getElementById('read-aloud-btn');
  const originalButtonText = readAloudButton.textContent;
  readAloudButton.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô...';
  readAloudButton.disabled = true;

  const audioUrl = await callGeminiTtsAPI(textToRead);

  // Re-enable button and play audio if successful
  readAloudButton.textContent = originalButtonText;
  readAloudButton.disabled = false;

  if (audioUrl) {
    audioPlayer.src = audioUrl;
    audioPlayer.play();
    showToast('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á');
  } else {
    showToast('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ');
  }
});

// Event listener for the new coordinate search button
document.getElementById('search-coords-btn').addEventListener('click', () => {
  const coordsInput = document.getElementById('coords-input').value;
  const parts = coordsInput.split(',');

  if (parts.length !== 2) {
    showToast('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î', 3000);
    return;
  }

  const lat = parseFloat(parts[0].trim());
  const lng = parseFloat(parts[1].trim());

  if (isNaN(lat) || isNaN(lng)) {
    showToast('‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 3000);
    return;
  }

  const latlng = L.latLng(lat, lng);
  map.setView(latlng, 12); // Set view and a good zoom level
  
  // Check if a temporary marker already exists and remove it
  if (currentLayer) {
    map.removeLayer(currentLayer);
  }

  // Create a new temporary marker at the searched location
  currentLayer = L.marker(latlng);
  currentLayer.addTo(map);

  // Open the modal to add details
  showMarkerModal(latlng);

  showToast(`‡∏¢‡πâ‡∏≤‡∏¢‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏õ‡∏ó‡∏µ‡πà: ${lat}, ${lng}`, 3000);
});
</script>

</body>
</html>
