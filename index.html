<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Map with HTML Support in Marker Details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet CSS and Plugins -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <!-- MarkerCluster CSS for grouping markers -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }

    /* Updated popup content to be more flexible */
    .leaflet-popup-content {
      max-width: 640px !important;
      max-height: 500px;
      overflow-y: auto;
    }
    
    .leaflet-popup-content img {
      max-width: 100%;
      height: auto;
      display: block; /* Prevents unwanted space below the image */
    }

    .leaflet-popup-content iframe {
      width: 100% !important;
      height: auto !important;
      aspect-ratio: 16 / 9;
      border: none;
    }
    
    /* Style for the video player */
    .leaflet-popup-content video {
      width: 100% !important;
      height: auto !important;
      background-color: #000;
    }

    .marker-content {
      margin-top: 10px;
      word-wrap: break-word; /* Ensures long text wraps */
      overflow-wrap: break-word; /* Alternative for better browser support */
    }

    .controls {
      position: absolute;
      top: 10px;
      left: 10.5%;
      transform: translateX(-50%);
      background: white;
      color: black;
      z-index: 1000;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      max-width: 200px;
      text-align: center;
    }
    
    .controls label, .controls input, .controls button {
      display: block;
      margin-top: 5px;
      width: 100%;
    }

    .toggle-btn {
      position: absolute;
      top: 10px;
      left: 55px;
      z-index: 1100;
      padding: 5px 10px;
      background: white;
      color: black;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: white;
      color: black;
      padding: 20px;
      border-radius: 10px;
      width: 400px;
      max-width: 90%;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .modal-content h2 {
      margin-top: 0;
    }

    .modal-content input,
    .modal-content textarea,
    .modal-content select {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    
    .modal-content .icon-preview {
        display: block;
        margin: 5px auto;
        width: 32px;
        height: 32px;
    }

    .modal-content button {
      padding: 8px 15px;
      margin-right: 10px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 5px;
    }

    .html-hint {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 10px;
    }
    .hidden {
      display: none;
    }
    .full-screen-btn {
        display: block;
        margin: 10px auto 0 auto;
        padding: 8px 15px;
        background-color: transparent;
        color: white;
        font-size: 1.2em;
        text-decoration: none;
        border-radius: 4px;
        text-align: center;
        font-weight: bold;
    }
    
    /* Toast Notification styles */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3000;
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
    }
    .toast {
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      margin-top: 10px;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    .toast.show {
      opacity: 1;
    }

    /* CSS for the tilt effect */
    #map.tilted {
      transform: perspective(1000px) rotateX(45deg);
      transition: transform 0.5s ease;
    }

    /* Styles for uploaded files list */
    .uploaded-files-container {
      margin-top: 10px;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }

    .uploaded-files-title {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .file-list {
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 5px;
      background: #f9f9f9;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      margin-bottom: 3px;
      background: white;
      border-radius: 3px;
    }

    .file-item:hover {
      background: #f0f0f0;
    }

    .delete-file {
      color: red;
      cursor: pointer;
      background: none;
      border: none;
      font-weight: bold;
      padding: 2px 5px;
    }

    .delete-file:hover {
      background: #ffebee;
    }
  </style>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.5/purify.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <!-- MarkerCluster JS for grouping markers -->
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
  <!-- Marked.js for Markdown support -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<button class="toggle-btn" onclick="toggleControls()">‚ò∞</button>
<div class="controls" id="toolbox">
  <h3>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠</h3>
  <label>üìÇ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
    <input type="file" id="file" accept=".geojson,.json,.kml,.gpx" />
  </label>
  <p class="html-hint">‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö .geojson, .kml, .gpx</p>
  
  <!-- Uploaded files list -->
  <div class="uploaded-files-container" id="uploadedFilesContainer">
    <div class="uploaded-files-title">‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î:</div>
    <div class="file-list" id="fileList"></div>
  </div>
  
  <hr>
  <h3>‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà</h3>
  <input type="text" id="coords-input" placeholder="‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà" />
  <button id="search-coords-btn">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</button>
  <hr>
  <label for="opacity-slider">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏∂‡∏ö‡πÅ‡∏™‡∏á‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ã‡πâ‡∏≠‡∏ô</label>
  <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="1" />
  <button id="toggle-tilt-btn">‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÄ‡∏≠‡∏µ‡∏¢‡∏á</button>
  <button id="saveGeoJSON">üíæ Export to GeoJSON</button>
  <button id="clear">üßπ Clear All</button>
  <button id="reset">üîÑ Reset View</button>
</div>

<div id="map"></div>

<!-- Modal to add marker details -->
<div class="modal" id="markerModal">
  <div class="modal-content">
    <h2>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î Marker</h2>
    <label for="icon-select">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô:</label>
    <select id="icon-select">
      <option value="">‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</option>
      <option value="https://i.ibb.co/mf8MtwZ/camera.png">‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ß‡∏á‡∏à‡∏£‡∏õ‡∏¥‡∏î</option>
      <option value="http://maps.google.com/mapfiles/kml/shapes/earthquake.png">‡πÅ‡∏ú‡πà‡∏ô‡∏î‡∏¥‡∏ô‡πÑ‡∏´‡∏ß</option>
      <option value="http://maps.google.com/mapfiles/kml/shapes/volcano.png">‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü</option>
      <option value="http://maps.google.com/mapfiles/kml/shapes/firedept.png">‡∏à‡∏∏‡∏î‡πÑ‡∏ü‡πÑ‡∏´‡∏°‡πâ</option>
      <option value="https://maphub.net/media/markers/3/ge/3geqzkryfqwmgmiu/80.png">‡∏ó‡∏∏‡πà‡∏ô‡∏™‡∏∂‡∏ô‡∏≤‡∏°‡∏¥</option>
      <option value="https://maphub.net/media/markers/g/fz/gfzwm2obnwflwz1x/80.png">‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®</option>
      <option value="https://maphub.net/media/markers/k/ce/kceab5neqjwcnxz6/80.png">‡∏¢‡∏π‡∏ó‡∏π‡∏õ</option>
    </select>
    <img id="icon-preview" class="icon-preview" src="" alt="Selected Icon" style="display:none;" />
    
    <label for="markerTitle">‡∏ä‡∏∑‡πà‡∏≠:</label>
    <input type="text" id="markerTitle" placeholder="‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠" />
    
    <label for="markerDesc">‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î:</label>
    <textarea id="markerDesc" placeholder='‡πÉ‡∏™‡πà‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Markdown ‡πÅ‡∏•‡∏∞ HTML)' rows="6"></textarea>
    <p class="html-hint">‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ Markdown ‡πÅ‡∏•‡∏∞‡πÅ‡∏ó‡∏£‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î HTML ‡πÑ‡∏î‡πâ ‡πÄ‡∏ä‡πà‡∏ô iframe ‡∏à‡∏≤‡∏Å Google Drive ‡∏´‡∏£‡∏∑‡∏≠ YouTube. ‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏™‡πà‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡πÉ‡∏´‡∏°‡πà</p>
    
    <button onclick="saveMarkerDetails()">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
    <button onclick="cancelMarkerDetails()">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
  </div>
</div>

<!-- Modal to confirm clearing all layers -->
<div class="modal" id="clearConfirmModal">
  <div class="modal-content">
    <h2>‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</h2>
    <p>‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏ó‡∏∏‡∏Å‡πÄ‡∏•‡πÄ‡∏¢‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞ Marker ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î?</p>
    <button onclick="confirmClear()">‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</button>
    <button onclick="cancelClear()">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
  </div>
</div>

<!-- Container for toast notifications -->
<div id="toast-container" class="toast-container"></div>
<audio id="audio-player"></audio>

<script>
const defaultView = [13.736717, 100.523186];
const map = L.map('map').setView(defaultView, 6);

// Define different base map layers
const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

const satelliteLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
    maxZoom: 19,
    attribution: 'Imagery &copy; Google Maps'
});

const hybridLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
    maxZoom: 19,
    attribution: 'Imagery &copy; Google Maps'
}).addTo(map); // Set as default layer

const topoMapLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    maxZoom: 17,
    attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
});

// Object to hold base map layers for the control
const baseMaps = {
    "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô": osmLayer,
    "‡∏†‡∏≤‡∏û‡∏ñ‡πà‡∏≤‡∏¢‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏°": satelliteLayer,
    "‡∏•‡∏π‡∏Å‡∏ú‡∏™‡∏°": hybridLayer,
    "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏†‡∏π‡∏°‡∏¥‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®": topoMapLayer
};

// Add the layers control to the map
L.control.layers(baseMaps).addTo(map);

const markers = L.markerClusterGroup();
map.addLayer(markers);

const drawnItems = new L.FeatureGroup().addTo(map);
let imageOverlay = null; // Store the image overlay layer

// Initialize the draw control for creating new shapes and markers
const drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems },
  draw: { 
    marker: { 
      icon: new L.Icon.Default(),
      draggable: true 
    }, 
    polyline: true, 
    polygon: true, 
    circle: true, 
    rectangle: true 
  }
});
map.addControl(drawControl);

let currentLayer = null;
const uploadedFiles = []; // Store uploaded files information

// Function to show a toast notification
function showToast(message, duration = 3000) {
  const toastContainer = document.getElementById('toast-container');
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  toastContainer.appendChild(toast);
  
  // Show toast with a slight delay
  setTimeout(() => toast.classList.add('show'), 10);
  
  // Hide toast after a duration
  setTimeout(() => {
    toast.classList.remove('show');
    // Remove toast from DOM after it fades out
    setTimeout(() => toast.remove(), 500); 
  }, duration);
}

let customIconUrl = '';

// Function to show the marker details modal
function showMarkerModal(latlng) {
  currentLayer.latlng = latlng; // Store the latlng on the layer
  document.getElementById('markerModal').style.display = 'flex';
  document.getElementById('markerTitle').value = '';
  document.getElementById('markerDesc').value = '';
  document.getElementById('icon-select').value = '';
  document.getElementById('icon-preview').style.display = 'none';
  customIconUrl = ''; // Reset the icon URL
}

// Function to save marker details and add to map
function saveMarkerDetails() {
  if (!currentLayer || !currentLayer.latlng) {
    console.error("Error: currentLayer or its latlng property is undefined.");
    return;
  }
  const title = document.getElementById('markerTitle').value || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠';
  const desc = document.getElementById('markerDesc').value || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î';
  const selectedIconUrl = document.getElementById('icon-select').value;
  
  // Create a custom icon if one is selected
  let finalMarker;
  if (selectedIconUrl) {
    const customIcon = L.icon({
      iconUrl: selectedIconUrl,
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    finalMarker = L.marker(currentLayer.latlng, { icon: customIcon });
  } else {
    // Use default marker
    finalMarker = L.marker(currentLayer.latlng);
  }

  // Convert Markdown text to HTML using marked.js
  const markdownHtml = marked.parse(desc);
  
  const cleanHtml = DOMPurify.sanitize(markdownHtml, {
    ALLOWED_TAGS: ['a', 'p', 'div', 'br', 'iframe', 'img', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'strong', 'em', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['href', 'src', 'width', 'height', 'frameborder', 'allowfullscreen', 'target', 'style', 'allow']
  });
  
  // Create a temporary element to safely modify the links
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = cleanHtml;
  
  // Find all links and add target="_blank"
  const links = tempDiv.querySelectorAll('a');
  links.forEach(link => {
      link.setAttribute('target', '_blank');
  });

  // Check for YouTube iframes and add a full-screen button
  const iframe = tempDiv.querySelector('iframe');
  let fullScreenButton = '';
  if (iframe) {
    const src = iframe.getAttribute('src');
    if (src && src.includes('youtube.com/embed')) {
      fullScreenButton = `<br><br><a href="${src}" target="_blank" style="display: inline-block; padding: 8px 15px; background-color: transparent; color: white; text-decoration: none; border-radius: 4px;">‡∏î‡∏π‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</a>`;
    }
  }

  const finalHtmlContent = tempDiv.innerHTML;
  
  const popupContent = `
    <div style="max-width:640px;">
      <b>${title}</b><br>
      <div class="marker-content">${finalHtmlContent}${fullScreenButton}</div>
    </div>
  `;

  finalMarker.bindPopup(popupContent, {
    maxWidth: 660,
    minWidth: 320
  });

  markers.addLayer(finalMarker); // Add marker to the cluster group
  document.getElementById('markerModal').style.display = 'none';
  if (currentLayer) {
    map.removeLayer(currentLayer); // Remove the temporary marker
  }
  currentLayer = null;
}

// Function to cancel marker creation
function cancelMarkerDetails() {
  document.getElementById('markerModal').style.display = 'none';
  if (currentLayer) {
    map.removeLayer(currentLayer);
  }
  currentLayer = null;
}

// Function to toggle the visibility of the control panel
function toggleControls() {
  document.getElementById('toolbox').classList.toggle('hidden');
}

// Show clear confirmation modal instead of using confirm()
document.getElementById('clear').addEventListener('click', () => {
  document.getElementById('clearConfirmModal').style.display = 'flex';
});

// Function to handle the "Clear" button in the confirmation modal
function confirmClear() {
  drawnItems.clearLayers();
  markers.clearLayers();
  if (imageOverlay) {
    map.removeLayer(imageOverlay);
    imageOverlay = null;
  }
  // Clear uploaded files list
  uploadedFiles.length = 0;
  updateFileList();
  document.getElementById('clearConfirmModal').style.display = 'none';
  showToast('‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß');
}

// Function to handle the "Cancel" button in the confirmation modal
function cancelClear() {
  document.getElementById('clearConfirmModal').style.display = 'none';
}

// Reset map view to the default location and zoom level
document.getElementById('reset').addEventListener('click', () => {
  map.setView(defaultView, 6);
  showToast('‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß');
});

// Function to update the uploaded files list
function updateFileList() {
  const fileListElement = document.getElementById('fileList');
  fileListElement.innerHTML = '';
  
  if (uploadedFiles.length === 0) {
    document.getElementById('uploadedFilesContainer').style.display = 'none';
    return;
  }
  
  document.getElementById('uploadedFilesContainer').style.display = 'block';
  
  uploadedFiles.forEach((file, index) => {
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    
    const fileNameSpan = document.createElement('span');
    fileNameSpan.textContent = file.name;
    
    const deleteButton = document.createElement('button');
    deleteButton.className = 'delete-file';
    deleteButton.textContent = '√ó';
    deleteButton.onclick = (e) => {
      e.stopPropagation();
      removeFile(index);
    };
    
    fileItem.appendChild(fileNameSpan);
    fileItem.appendChild(deleteButton);
    fileListElement.appendChild(fileItem);
  });
}

// Function to remove a file from the list and map
function removeFile(index) {
  if (index >= 0 && index < uploadedFiles.length) {
    const file = uploadedFiles[index];
    
    // Remove the layer from the map
    if (file.layer) {
      if (file.layer.eachLayer) {
        // For layer groups
        file.layer.eachLayer(layer => {
          if (layer instanceof L.Marker) {
            markers.removeLayer(layer);
          } else {
            drawnItems.removeLayer(layer);
          }
        });
      } else {
        // For single layers
        if (file.layer instanceof L.Marker) {
          markers.removeLayer(file.layer);
        } else {
          drawnItems.removeLayer(file.layer);
        }
      }
      
      // Remove from the map if it's a direct layer
      if (map.hasLayer(file.layer)) {
        map.removeLayer(file.layer);
      }
    }
    
    // Remove from the array
    uploadedFiles.splice(index, 1);
    updateFileList();
    showToast(`‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå ${file.name} ‡πÅ‡∏•‡πâ‡∏ß`);
  }
}

// New code for file upload
document.getElementById('file').addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (!file) {
    return;
  }

  const reader = new FileReader();
  reader.onload = function (event) {
    const content = event.target.result;
    const extension = file.name.split('.').pop().toLowerCase();

    // Check for KML files with a GroundOverlay
    if (extension === 'kml' && content.includes('<GroundOverlay>')) {
      try {
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(content, 'text/xml');
        const groundOverlays = kmlDoc.querySelectorAll('GroundOverlay');

        groundOverlays.forEach(overlay => {
          const latLonBox = overlay.querySelector('LatLonBox');
          const href = overlay.querySelector('Icon href');
          
          if (latLonBox && href) {
            const north = parseFloat(latLonBox.querySelector('north').textContent);
            const south = parseFloat(latLonBox.querySelector('south').textContent);
            const east = parseFloat(latLonBox.querySelector('east').textContent);
            const west = parseFloat(latLonBox.querySelector('west').textContent);
            const imageUrl = href.textContent;
            
            const bounds = [[south, west], [north, east]];
            
            if (imageOverlay) {
              map.removeLayer(imageOverlay);
            }
            
            imageOverlay = L.imageOverlay(imageUrl, bounds, { opacity: parseFloat(document.getElementById('opacity-slider').value) }).addTo(map);
            map.fitBounds(bounds);
            
            // Add to uploaded files list
            uploadedFiles.push({
              name: file.name,
              type: extension,
              layer: imageOverlay
            });
            updateFileList();
            
            showToast('‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ã‡πâ‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå KML ‡πÅ‡∏•‡πâ‡∏ß');
          }
        });
      } catch (error) {
        showToast(`Error parsing KML GroundOverlay file: ${error.message}`, 5000);
        return;
      }
    } else {
      // Use omnivore for all other KML features, GeoJSON, and GPX
      let layer;
      try {
        if (extension === 'geojson' || extension === 'json') {
          layer = L.geoJSON(JSON.parse(content));
        } else if (extension === 'kml') {
          layer = omnivore.kml.parse(content);
        } else if (extension === 'gpx') {
          layer = omnivore.gpx.parse(content);
        }
      } catch (error) {
        showToast(`Error parsing file: ${error.message}`, 5000);
        return;
      }
      
      if (layer) {
        const fileInfo = {
          name: file.name,
          type: extension,
          layer: layer
        };
        
        uploadedFiles.push(fileInfo);
        updateFileList();
        
        layer.eachLayer(function(l) {
          if (l instanceof L.Marker) {
            markers.addLayer(l); // Add markers to the cluster group
            setupPopup(l, l.feature ? l.feature.properties : null);
          } else {
            drawnItems.addLayer(l); // Add other shapes to the drawn items group
            setupPopup(l, l.feature ? l.feature.properties : null);
          }
        });
        
        const bounds = layer.getBounds();
        if (bounds.isValid()) {
          map.fitBounds(bounds);
        } else {
          showToast('‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏ó‡∏≤‡∏á‡∏†‡∏π‡∏°‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 5000);
        }
        showToast('‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏•‡πâ‡∏ß');
      } else {
        showToast('‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á!', 5000);
      }
    }
  };

  // Reset file input
  e.target.value = '';
  reader.readAsText(file);
});

// Function to set up the popup for a given layer
function setupPopup(layer, properties) {
  if (properties) {
    let popupContent = "";
    const description = properties.description || '';
    const m3u8UrlMatch = description.match(/(https?:\/\/[^\s]+\.m3u8)/);

    if (properties.name) {
      popupContent += `<b>${properties.name}</b><br>`;
    }

    if (m3u8UrlMatch) {
      const m3u8Url = m3u8UrlMatch[0];
      popupContent += `
        <div class="marker-content">
          <video id="hls-video-${L.stamp(layer)}" class="hls-video-player" controls muted></video>
          <a href="${m3u8Url}" target="_blank" class="full-screen-btn">‡∏î‡∏π‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠</a>
        </div>
      `;
      layer.on('popupopen', function() {
        const video = document.getElementById(`hls-video-${L.stamp(layer)}`);
        if (Hls.isSupported() && video) {
          var hls = new Hls();
          hls.loadSource(m3u8Url);
          hls.attachMedia(video);
          hls.on(Hls.Events.MANIFEST_PARSED, function() {
            video.play();
          });
        } else if (video && video.canPlayType('application/vnd.apple.mpegurl')) {
          video.src = m3u8Url;
          video.addEventListener('loadedmetadata', function() {
            video.play();
          });
        }
      });
    } else if (description) {
      const isHtml = /<[a-z][\s\S]*>/i.test(description);
      const formattedContent = isHtml ? description : marked.parse(description);

      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = formattedContent;
      
      const links = tempDiv.querySelectorAll('a');
      links.forEach(link => {
          link.setAttribute('target', '_blank');
      });
      
      const iframe = tempDiv.querySelector('iframe');
      let fullScreenButton = '';
      if (iframe) {
        const src = iframe.getAttribute('src');
        if (src && src.includes('youtube.com/embed')) {
          fullScreenButton = `<br><br><a href="${src}" target="_blank" style="display: inline-block; padding: 8px 15px; background-color: transparent; color: white; text-decoration: none; border-radius: 4px;">‡∏î‡∏π‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</a>`;
        }
      }
      
      const finalHtmlContent = tempDiv.innerHTML;
      popupContent += `<div class="marker-content">${finalHtmlContent}${fullScreenButton}</div>`;
    }
    
    if (popupContent) {
      layer.bindPopup(popupContent, {
        maxWidth: 660,
        minWidth: 320
      });
    }
  }
}

// Event listener for the opacity slider
document.getElementById('opacity-slider').addEventListener('input', (e) => {
  const opacity = e.target.value;
  if (imageOverlay) {
    imageOverlay.setOpacity(opacity);
  }
});

// New event listener for the tilt button
document.getElementById('toggle-tilt-btn').addEventListener('click', () => {
  const mapElement = document.getElementById('map');
  mapElement.classList.toggle('tilted');
});

// Event listener to show a preview of the selected icon
document.getElementById('icon-select').addEventListener('change', (e) => {
    const iconUrl = e.target.value;
    const iconPreview = document.getElementById('icon-preview');
    if (iconUrl) {
        iconPreview.src = iconUrl;
        iconPreview.style.display = 'block';
    } else {
        iconPreview.style.display = 'none';
    }
});

// Handle the creation of new layers
map.on(L.Draw.Event.CREATED, function (e) {
  const layer = e.layer;
  if (e.layerType === 'marker') {
    currentLayer = layer;
    showMarkerModal(e.layer.getLatLng()); // Pass the latlng to the modal function
  } else {
    // Add other shapes directly to the drawnItems layer group
    drawnItems.addLayer(layer);
  }
});

// Event listener for the new coordinate search button
document.getElementById('search-coords-btn').addEventListener('click', () => {
  const searchInput = document.getElementById('coords-input').value.trim();
  
  // Check if input is coordinates (lat,lng)
  const coordsPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$/;
  if (coordsPattern.test(searchInput)) {
    const parts = searchInput.split(',');
    const lat = parseFloat(parts[0].trim());
    const lng = parseFloat(parts[1].trim());

    if (isNaN(lat) || isNaN(lng)) {
      showToast('‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 3000);
      return;
    }

    const latlng = L.latLng(lat, lng);
    handleSearchResult(latlng, `‡∏û‡∏¥‡∏Å‡∏±‡∏î: ${lat}, ${lng}`);
  } else {
    // Treat as place name - use Nominatim for geocoding
    if (!searchInput) {
      showToast('‡πÇ‡∏õ‡∏£‡∏î‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î', 3000);
      return;
    }
    
    showToast('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà...', 3000);
    
    // Use Nominatim API for geocoding
    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchInput)}&limit=1`)
      .then(response => response.json())
      .then(data => {
        if (data && data.length > 0) {
          const result = data[0];
          const latlng = L.latLng(result.lat, result.lon);
          handleSearchResult(latlng, result.display_name);
        } else {
          showToast('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤', 3000);
        }
      })
      .catch(error => {
        console.error('Geocoding error:', error);
        showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤', 3000);
      });
  }
});

// Function to handle search results (both coordinates and place names)
function handleSearchResult(latlng, displayText) {
  map.setView(latlng, 12); // Set view and a good zoom level
  
  // Check if a temporary marker already exists and remove it
  if (currentLayer) {
    map.removeLayer(currentLayer);
  }

  // Create a new temporary marker at the searched location
  currentLayer = L.marker(latlng);
  currentLayer.addTo(map);

  // Open the modal to add details
  showMarkerModal(latlng);

  showToast(`‡∏û‡∏ö: ${displayText}`, 3000);
}

// Initialize the uploaded files container as hidden
document.getElementById('uploadedFilesContainer').style.display = 'none';
</script>

</body>
</html>
